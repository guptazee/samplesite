<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gesture Controlled Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        canvas { display: block; }
        #video-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 150px;
            border: 2px solid #333;
            border-radius: 10px;
            overflow: hidden;
            z-index: 10;
            transform: scaleX(-1); /* Mirror video */
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            pointer-events: none;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffcc;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
        }
    </style>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <div id="loading">Loading Computer Vision...</div>
    <div id="video-container">
        <video id="input_video"></video>
    </div>
    <div id="ui">
        <h3>Gesture Controls</h3>
        <p>üñê Move hand to position</p>
        <p>üëå Pinch to resize/color</p>
        <p>‚òùÔ∏è 1 Finger: Sphere</p>
        <p>‚úåÔ∏è 2 Fingers: Heart</p>
        <p>ü§ü 3 Fingers: Flower</p>
        <p>üññ 4 Fingers: Saturn</p>
        <p>üñê 5 Fingers: Fireworks</p>
        <div id="status">Shape: Sphere</div>
    </div>

<script>
    // --- Configuration ---
    const PARTICLE_COUNT = 15000;
    const MORPH_SPEED = 0.08;
    
    // --- Three.js Setup ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.002);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 30;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // --- Particle System ---
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    const targetPositions = new Float32Array(PARTICLE_COUNT * 3); // Where particles want to go
    
    // Initialize random positions
    for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 100;
        targetPositions[i] = positions[i];
        colors[i] = 1;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // Custom Shader Material for glowing particles
    const material = new THREE.PointsMaterial({
        size: 0.15,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.8
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- State Variables ---
    let currentShape = 'sphere';
    let handPosition = new THREE.Vector3(0, 0, 0);
    let scaleFactor = 1;
    let colorShift = 0;

    // --- Shape Generators ---
    // Helper to get random point in sphere
    function getSpherePoint(r) {
        const theta = Math.random() * 2 * Math.PI;
        const phi = Math.acos(2 * Math.random() - 1);
        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);
        return {x, y, z};
    }

    const shapes = {
        sphere: () => {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const p = getSpherePoint(8);
                targetPositions[i*3] = p.x;
                targetPositions[i*3+1] = p.y;
                targetPositions[i*3+2] = p.z;
            }
        },
        heart: () => {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Heart formula
                let t = Math.random() * Math.PI * 2;
                // Distribute points to fill volume slightly
                let r = Math.pow(Math.random(), 0.3); 
                
                // 2D Heart outline extended to 3D volume
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let z = (Math.random() - 0.5) * 4; // Thickness

                const scale = 0.5 * r;
                targetPositions[i*3] = x * scale;
                targetPositions[i*3+1] = y * scale;
                targetPositions[i*3+2] = z;
            }
        },
        flower: () => {
             for (let i = 0; i < PARTICLE_COUNT; i++) {
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                
                // Modulate radius based on angle to create petals
                const petal = Math.abs(Math.cos(theta * 3) * Math.sin(phi * 3)) * 4 + 4;
                
                const x = petal * Math.sin(phi) * Math.cos(theta);
                const y = petal * Math.sin(phi) * Math.sin(theta);
                const z = petal * Math.cos(phi);

                targetPositions[i*3] = x;
                targetPositions[i*3+1] = y;
                targetPositions[i*3+2] = z;
            }
        },
        saturn: () => {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // 70% particles for planet, 30% for rings
                if (i < PARTICLE_COUNT * 0.7) {
                    const p = getSpherePoint(5);
                    targetPositions[i*3] = p.x;
                    targetPositions[i*3+1] = p.y;
                    targetPositions[i*3+2] = p.z;
                } else {
                    // Ring
                    const angle = Math.random() * Math.PI * 2;
                    const r = 8 + Math.random() * 4; // Ring radius 8 to 12
                    targetPositions[i*3] = r * Math.cos(angle);
                    targetPositions[i*3+1] = (Math.random()-0.5) * 0.5; // Flat y
                    targetPositions[i*3+2] = r * Math.sin(angle);
                    
                    // Tilt the ring
                    const tempY = targetPositions[i*3+1];
                    const tempZ = targetPositions[i*3+2];
                    const tilt = 0.4;
                    targetPositions[i*3+1] = tempY * Math.cos(tilt) - tempZ * Math.sin(tilt);
                    targetPositions[i*3+2] = tempY * Math.sin(tilt) + tempZ * Math.cos(tilt);
                }
            }
        },
        fireworks: () => {
             for (let i = 0; i < PARTICLE_COUNT; i++) {
                 // Random explosion
                const p = getSpherePoint(Math.random() * 15 + 2);
                targetPositions[i*3] = p.x;
                targetPositions[i*3+1] = p.y;
                targetPositions[i*3+2] = p.z;
             }
        }
    };

    // Initial shape
    shapes.sphere();

    function switchShape(shapeName) {
        if (currentShape !== shapeName) {
            currentShape = shapeName;
            document.getElementById('status').innerText = "Shape: " + shapeName.charAt(0).toUpperCase() + shapeName.slice(1);
            if(shapes[shapeName]) shapes[shapeName]();
        }
    }

    // --- MediaPipe Hands Setup ---
    const videoElement = document.getElementById('input_video');
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });

    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 320,
        height: 240
    });
    cameraUtils.start().then(() => {
        document.getElementById('loading').style.display = 'none';
    });

    // --- Interaction Logic ---
    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];

            // 1. Position Tracking (Index Finger Tip - Landmark 8)
            // Map 0..1 coordinates to 3D world space (approx -15 to 15)
            // X is mirrored
            const x = (0.5 - landmarks[8].x) * 30; 
            const y = (0.5 - landmarks[8].y) * 20; 
            
            // Smoothly interpolate hand position
            handPosition.lerp(new THREE.Vector3(x, y, 0), 0.1);

            // 2. Pinch Detection (Thumb Tip 4 vs Index Tip 8)
            const dx = landmarks[4].x - landmarks[8].x;
            const dy = landmarks[4].y - landmarks[8].y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            
            // Map distance to scale (Close pinch = 0.5, Open = 2.0)
            const targetScale = 0.5 + (distance * 5); 
            scaleFactor += (targetScale - scaleFactor) * 0.1;
            
            // Map distance to color
            colorShift = distance * 2; // 0 to 1 range approx

            // 3. Gesture/Shape Switching (Count Fingers)
            // A finger is "up" if the tip is higher (lower y value) than the PIP joint
            let fingersUp = 0;
            if (landmarks[8].y < landmarks[6].y) fingersUp++; // Index
            if (landmarks[12].y < landmarks[10].y) fingersUp++; // Middle
            if (landmarks[16].y < landmarks[14].y) fingersUp++; // Ring
            if (landmarks[20].y < landmarks[18].y) fingersUp++; // Pinky
            if (landmarks[4].x < landmarks[3].x) fingersUp++; // Thumb (approx for right hand mirrored)

            // Simple debounce logic could be added here, but direct mapping is responsive
            if (fingersUp === 1) switchShape('sphere');
            else if (fingersUp === 2) switchShape('heart');
            else if (fingersUp === 3) switchShape('flower');
            else if (fingersUp === 4) switchShape('saturn');
            else if (fingersUp === 5) switchShape('fireworks');
        }
    }

    // --- Animation Loop ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        
        const time = clock.getElapsedTime();
        const positionsAttribute = geometry.attributes.position;
        const colorsAttribute = geometry.attributes.color;

        // Rotate the entire particle system slightly
        particles.rotation.y += 0.002;
        particles.rotation.z = Math.sin(time * 0.5) * 0.05;

        // Smoothly move the container to hand position
        particles.position.lerp(handPosition, 0.05);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const ix = i * 3;
            const iy = i * 3 + 1;
            const iz = i * 3 + 2;

            // 1. Morph positions: Interpolate current to target
            // Apply scale factor to the target destination
            let tx = targetPositions[ix] * scaleFactor;
            let ty = targetPositions[iy] * scaleFactor;
            let tz = targetPositions[iz] * scaleFactor;

            // Add some noise/movement
            tx += Math.sin(time + positionsAttribute.array[iy]) * 0.05;
            ty += Math.cos(time + positionsAttribute.array[ix]) * 0.05;

            // Linear interpolation (Lerp) manually
            positionsAttribute.array[ix] += (tx - positionsAttribute.array[ix]) * MORPH_SPEED;
            positionsAttribute.array[iy] += (ty - positionsAttribute.array[iy]) * MORPH_SPEED;
            positionsAttribute.array[iz] += (tz - positionsAttribute.array[iz]) * MORPH_SPEED;

            // 2. Dynamic Colors
            // Base color changes over time + pinch influence
            const r = 0.5 + 0.5 * Math.sin(time * 0.5 + positionsAttribute.array[ix] * 0.1);
            const g = 0.5 + 0.5 * Math.cos(time * 0.3 + positionsAttribute.array[iy] * 0.1 + colorShift);
            const b = 0.5 + 0.5 * Math.sin(time * 0.7 + colorShift * 2);

            colorsAttribute.array[ix] = r;
            colorsAttribute.array[iy] = g;
            colorsAttribute.array[iz] = b;
        }

        positionsAttribute.needsUpdate = true;
        colorsAttribute.needsUpdate = true;
        
        // Update size based on pinch
        material.size = 0.1 + (scaleFactor * 0.1);

        renderer.render(scene, camera);
    }

    // Handle Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();

</script>
</body>
</html>
